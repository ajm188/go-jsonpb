package gen

import (
	"fmt"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/types/pluginpb"
)

// Options represents the flags passed to protoc-gen-go-json via the protoc command line.
type Options struct {
	GithubProtobuf bool
}

// GeneratedFile is the set of methods needed by protoc-gen-go-json
// on *protogen.GeneratedFile. It exists mainly for ease of testing.
type GeneratedFile interface {
	P(...interface{})
}

// GenerateFile generates the jsonpb/protojson marshaler implementations for every Message
// in the input proto file.
func GenerateFile(g GeneratedFile, req *pluginpb.CodeGeneratorRequest, file *protogen.File, opts Options) {
	GenerateHeader(g, req, file)

	g.P("package ", file.GoPackageName)
	g.P()

	if opts.GithubProtobuf {
		g.P("import (")
		g.P(`"bytes"`)
		g.P()
		g.P(`"github.com/golang/protobuf/jsonpb"`)
		g.P(")")
	} else {
		g.P(`import "google.golang.org/protobuf/encoding/protojson"`)
	}
	g.P()

	GenerateMarshalers(g, collectMessages(file), opts)
}

// GenerateHeader generates the header comments, which contain information about the
// build tools and arguments.
func GenerateHeader(g GeneratedFile, req *pluginpb.CodeGeneratorRequest, file *protogen.File) {
	protocVersion := "(unknown)"
	if v := req.GetCompilerVersion(); v != nil {
		protocVersion = fmt.Sprintf("v%v.%v.%v", v.GetMajor(), v.GetMinor(), v.GetPatch())
	}

	g.P("// Code generated by protoc-gen-go-json. DO NOT EDIT.")
	g.P("// versions:")
	g.P("// \tprotoc-gen-go-json ", "(unknown)")
	g.P("// \tprotoc             ", protocVersion)

	if file.Proto.GetOptions().GetDeprecated() {
		g.P("// ", file.Desc.Path(), " is a deprecated file.")
	} else {
		g.P("// source: ", file.Desc.Path())
	}

	g.P()
}

// GenerateMarshalers generates the actual MarshalJSON implementations for each Message
// in the input file.
func GenerateMarshalers(g GeneratedFile, messages []*protogen.Message, opts Options) {
	for _, message := range messages {
		g.P("func (x *", message.GoIdent, ") MarshalJSON() ([]byte, error) {")
		if opts.GithubProtobuf {
			g.P("buf := bytes.Buffer{}")
			g.P("m := jsonpb.Marshaler{}")
			g.P()
			g.P("if err := m.Marshal(&buf, x); err != nil {")
			g.P("return nil, err")
			g.P("}")
			g.P()
			g.P("return buf.Bytes(), nil")
		} else {
			g.P("return protojson.Marshal(x)")
		}
		g.P("}")
		g.P()
	}
}

// Implementation lifted nearly wholesale from protoc-gen-go.
// https://github.com/protocolbuffers/protobuf-go/blob/db5c900f0ce544131509b33f6d68ec651e3ca91c/cmd/protoc-gen-go/internal_gengo/init.go#L50-L84
func collectMessages(file *protogen.File) []*protogen.Message {
	allMessages := []*protogen.Message{}

	var walk func([]*protogen.Message, func(*protogen.Message))
	walk = func(messages []*protogen.Message, f func(*protogen.Message)) {
		for _, m := range messages {
			f(m)
			walk(m.Messages, f)
		}
	}

	initMessages := func(messages []*protogen.Message) {
		allMessages = append(allMessages, messages...)
	}

	initMessages(file.Messages)
	walk(file.Messages, func(m *protogen.Message) {
		initMessages(m.Messages)
	})

	return allMessages
}
