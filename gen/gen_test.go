package gen

import (
	"fmt"
	"strings"
	"testing"

	"github.com/stretchr/testify/assert"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/descriptorpb"
	"google.golang.org/protobuf/types/pluginpb"
)

var (
	major int32 = 1
	minor int32 = 2
	patch int32 = 3

	deprecated bool = true

	req = &pluginpb.CodeGeneratorRequest{
		CompilerVersion: &pluginpb.Version{
			Major: &major,
			Minor: &minor,
			Patch: &patch,
		},
	}
)

type TestFile struct {
	b []string
}

type TestProtoFD struct {
	protoreflect.FileDescriptor // embed but do not implement (all of) the interface
	path                        string
}

func (fd *TestProtoFD) Path() string {
	return fd.path
}

func (tf *TestFile) P(ts ...interface{}) {
	b := strings.Builder{}
	for _, t := range ts {
		switch t := t.(type) {
		case protogen.GoIdent:
			b.WriteString(tf.QualifiedGoIdent(t))
		default:
			b.WriteString(fmt.Sprint(t))
		}
	}

	tf.b = append(tf.b, b.String())
}

// This is a deliberately incomplete implementation of protogen.GeneratedFile.QualifiedGoIdent
// (see https://github.com/protocolbuffers/protobuf-go/blob/db5c900f0ce544131509b33f6d68ec651e3ca91c/compiler/protogen/protogen.go#L1056).
// We're only testing intra-package identifiers, so the other cases aren't worth considering.
func (tf *TestFile) QualifiedGoIdent(t protogen.GoIdent) string {
	return t.GoName
}

func TestGenerateHeader(t *testing.T) {
	tests := []struct {
		name  string
		file  *protogen.File
		lines []string
	}{
		{
			name: "string",
			file: &protogen.File{Desc: &TestProtoFD{path: "test.proto"}},
			lines: []string{
				"// Code generated by protoc-gen-go-json. DO NOT EDIT.",
				"// versions:",
				"// \tprotoc-gen-go-json (unknown)",
				"// \tprotoc             v1.2.3",
				"// source: test.proto",
				"",
			},
		},
		{
			name: "deprecated",
			file: &protogen.File{
				Desc: &TestProtoFD{path: "test.proto"},
				Proto: &descriptorpb.FileDescriptorProto{
					Options: &descriptorpb.FileOptions{
						Deprecated: &deprecated,
					},
				},
			},
			lines: []string{
				"// Code generated by protoc-gen-go-json. DO NOT EDIT.",
				"// versions:",
				"// \tprotoc-gen-go-json (unknown)",
				"// \tprotoc             v1.2.3",
				"// test.proto is a deprecated file.",
				"",
			},
		},
	}

	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			g := &TestFile{b: []string{}}
			GenerateHeader(g, req, test.file)

			assert.Equal(t, test.lines, g.b, "Got %+v", g.b)
		})
	}
}

func TestGenerateMarshalers(t *testing.T) {
	tests := []struct {
		name     string
		messages []*protogen.Message
		lines    []string
	}{
		{
			name: "",
			messages: []*protogen.Message{
				{
					GoIdent: protogen.GoIdent{GoName: "T1"},
				},
				{
					GoIdent: protogen.GoIdent{GoName: "T2"},
				},
			},
			lines: []string{
				"func (x *T1) MarshalJSON() ([]byte, error) {",
				"return protojson.Marshal(x)",
				"}",
				"",
				"func (x *T2) MarshalJSON() ([]byte, error) {",
				"return protojson.Marshal(x)",
				"}",
				"",
			},
		},
		{
			name:     "empty message list",
			messages: []*protogen.Message{},
			lines:    []string{},
		},
	}

	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			g := &TestFile{b: []string{}}
			GenerateMarshalers(g, test.messages)

			assert.Equal(t, test.lines, g.b)
		})
	}
}

func TestCollectMessages(t *testing.T) {
	tests := []struct {
		name     string
		file     *protogen.File
		messages []string
	}{
		{
			name: "flat file",
			file: &protogen.File{
				Messages: []*protogen.Message{
					{
						GoIdent:  protogen.GoIdent{GoName: "T1"},
						Messages: []*protogen.Message{},
					},
					{
						GoIdent:  protogen.GoIdent{GoName: "T2"},
						Messages: []*protogen.Message{},
					},
				},
			},
			messages: []string{
				"T1",
				"T2",
			},
		},
		{
			name: "mixed nesting",
			file: &protogen.File{
				Messages: []*protogen.Message{
					{
						GoIdent: protogen.GoIdent{GoName: "T1"},
						Messages: []*protogen.Message{
							{
								GoIdent:  protogen.GoIdent{GoName: "T1_A"},
								Messages: []*protogen.Message{},
							},
						},
					},
					{
						GoIdent: protogen.GoIdent{GoName: "T2"},
						Messages: []*protogen.Message{
							{
								GoIdent: protogen.GoIdent{GoName: "T2_A"},
								Messages: []*protogen.Message{
									{
										GoIdent:  protogen.GoIdent{GoName: "T2_A_1"},
										Messages: []*protogen.Message{},
									},
								},
							},
							{
								GoIdent:  protogen.GoIdent{GoName: "T2_B"},
								Messages: []*protogen.Message{},
							},
						},
					},
					{
						GoIdent:  protogen.GoIdent{GoName: "T3"},
						Messages: []*protogen.Message{},
					},
				},
			},
			messages: []string{
				"T1",
				"T2",
				"T3",
				"T1_A",
				"T2_A",
				"T2_B",
				"T2_A_1",
			},
		},
	}

	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			messages := collectMessages(test.file)
			messageNames := make([]string, len(messages))
			for i, message := range messages {
				messageNames[i] = message.GoIdent.GoName
			}

			assert.Equal(t, test.messages, messageNames)
		})
	}
}
